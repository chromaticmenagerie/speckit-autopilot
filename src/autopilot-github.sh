#!/usr/bin/env bash
# autopilot-github.sh — GitHub Projects integration for the autopilot orchestrator.
# Syncs epic/task state to a GitHub Projects board via gh CLI.
# All functions are non-fatal: GitHub sync failures never block the pipeline.
#
# Split into two files:
#   autopilot-github.sh      — Setup: globals, detection, project creation, caching
#   autopilot-github-sync.sh — Operations: issue creation, status sync, resync

# ─── Global State ───────────────────────────────────────────────────────────

GH_ENABLED=false
GH_CONSECUTIVE_FAILS=0
GH_SYNC_LOG=""
GH_PROJECT_NUM=""
GH_PROJECT_NODE_ID=""
GH_FIELD_STATUS_ID=""
GH_USER=""
GH_OWNER=""
GH_OWNER_REPO=""
declare -A GH_STATUS_OPT  # status_name → option_id

# ─── Error Wrapper ──────────────────────────────────────────────────────────

# Wraps gh commands with error counting + logging.
# Usage: gh_try "description" gh project item-edit ...
# Returns: 0 on success (output on stdout), 1 on failure.
gh_try() {
    local desc="$1"; shift
    local output rc=0
    output=$("$@" 2>&1) || rc=$?

    if [[ $rc -ne 0 ]]; then
        GH_CONSECUTIVE_FAILS=$((GH_CONSECUTIVE_FAILS + 1))
        echo "[$(date -Iseconds)] FAIL: $desc — $output" >> "$GH_SYNC_LOG"

        if [[ $GH_CONSECUTIVE_FAILS -ge 3 ]]; then
            log WARN "GitHub sync: $GH_CONSECUTIVE_FAILS consecutive failures — check $GH_SYNC_LOG"
        fi

        # Auth failure → disable for session
        if [[ "$output" == *"auth"* ]] || [[ "$output" == *"401"* ]] || [[ "$output" == *"403"* ]]; then
            GH_ENABLED=false
            log WARN "GitHub auth failure — sync disabled for this session"
        fi
        return 1
    fi

    GH_CONSECUTIVE_FAILS=0
    echo "$output"
}

# ─── Auto-Detection ────────────────────────────────────────────────────────

# Layered check: flag → binary → auth → scope.
# Sets GH_ENABLED=true or leaves it false. Never exits.
gh_detect() {
    if $NO_GITHUB; then
        log INFO "GitHub sync disabled (--no-github)"
        return
    fi

    if ! command -v gh >/dev/null 2>&1; then
        log INFO "gh CLI not found — GitHub sync disabled"
        return
    fi

    if ! gh auth status >/dev/null 2>&1; then
        log INFO "gh not authenticated — GitHub sync disabled"
        return
    fi

    local user
    user=$(gh api user --jq '.login' 2>/dev/null) || {
        log WARN "gh missing project scope — run: gh auth refresh -s project"
        return
    }

    GH_USER="$user"
    GH_ENABLED=true
    GH_SYNC_LOG="${REPO_ROOT}/.specify/logs/github-sync.log"
    mkdir -p "$(dirname "$GH_SYNC_LOG")"
    log INFO "GitHub sync enabled (user=$GH_USER)"
}

# ─── Phase Mapping ──────────────────────────────────────────────────────────

# Maps internal phase names to GitHub's 3 default board statuses.
_gh_phase_to_status() {
    case "$1" in
        implement|review|finalize-fix|finalize-review|crystallize)
            echo "In Progress" ;;
        done)
            echo "Done" ;;
        *)
            echo "Todo" ;;
    esac
}

# ─── Project Setup ──────────────────────────────────────────────────────────

# Extract owner/repo from git remote. Sets GH_OWNER and GH_OWNER_REPO.
_gh_parse_remote() {
    local repo_root="$1"
    local url
    url=$(git -C "$repo_root" remote get-url origin 2>/dev/null) || return 1

    # Handle SSH (git@github.com:org/repo.git) and HTTPS (https://github.com/org/repo.git)
    GH_OWNER_REPO=$(echo "$url" | sed -E 's#(git@|https://)github\.com[:/]##; s/\.git$//')
    GH_OWNER="${GH_OWNER_REPO%%/*}"
}

# Load cached IDs from project-board.env into globals + associative array.
_gh_load_cache() {
    local env_file="$1"
    [[ -f "$env_file" ]] || return 1

    # shellcheck disable=SC1090
    source "$env_file"

    # Rebuild associative array from GH_STATUS_OPT_* vars (underscores → spaces)
    local var
    for var in $(compgen -v GH_STATUS_OPT_); do
        local safe_name="${var#GH_STATUS_OPT_}"
        local status_name="${safe_name//_/ }"
        GH_STATUS_OPT["$status_name"]="${!var}"
    done

    # Invalidate cache if required statuses missing
    if [[ -z "${GH_STATUS_OPT[Todo]:-}" ]] || \
       [[ -z "${GH_STATUS_OPT[In Progress]:-}" ]] || \
       [[ -z "${GH_STATUS_OPT[Done]:-}" ]]; then
        log WARN "Cache missing required status options — invalidating"
        GH_STATUS_OPT=()
        return 1
    fi
    return 0
}

# Write current state to project-board.env cache.
_gh_write_cache() {
    local env_file="$1"
    {
        echo "# Auto-generated by autopilot-github.sh — do not edit"
        echo "GH_PROJECT_NUM=\"$GH_PROJECT_NUM\""
        echo "GH_PROJECT_NODE_ID=\"$GH_PROJECT_NODE_ID\""
        echo "GH_FIELD_STATUS_ID=\"$GH_FIELD_STATUS_ID\""
        echo "GH_USER=\"$GH_USER\""
        echo "GH_OWNER=\"$GH_OWNER\""
        echo "GH_OWNER_REPO=\"$GH_OWNER_REPO\""
        for status_name in "${!GH_STATUS_OPT[@]}"; do
            local safe_name="${status_name// /_}"
            echo "GH_STATUS_OPT_${safe_name}=\"${GH_STATUS_OPT[$status_name]}\""
        done
    } > "$env_file"
}

# Idempotent project setup: create project, link, set up Status field, cache IDs.
gh_ensure_project() {
    local repo_root="$1"
    local env_file="$repo_root/.specify/project-board.env"

    # Try cached IDs first
    if _gh_load_cache "$env_file"; then
        if gh project view "$GH_PROJECT_NUM" --owner "$GH_OWNER" >/dev/null 2>&1; then
            log INFO "GitHub project loaded from cache (project #$GH_PROJECT_NUM)"
            return 0
        fi
        log WARN "Cached project not found — recreating"
        rm -f "$env_file"
    fi

    _gh_parse_remote "$repo_root" || {
        log WARN "No git remote — GitHub sync disabled"
        GH_ENABLED=false
        return 1
    }

    local project_title="Autopilot: $(basename "$(git -C "$repo_root" rev-parse --show-toplevel)")"

    # Find existing project by title
    local projects_json
    projects_json=$(gh_try "list projects" gh project list --owner "$GH_OWNER" --format json --limit 100) || {
        log WARN "Failed to list projects"
        GH_ENABLED=false
        return 1
    }

    GH_PROJECT_NUM=$(echo "$projects_json" | jq -r --arg t "$project_title" \
        '.projects[] | select(.title == $t) | .number' 2>/dev/null | head -1)

    if [[ -z "$GH_PROJECT_NUM" ]] || [[ "$GH_PROJECT_NUM" == "null" ]]; then
        local create_out
        create_out=$(gh_try "create project" gh project create --owner "$GH_OWNER" --title "$project_title" --format json) || {
            GH_ENABLED=false
            return 1
        }
        GH_PROJECT_NUM=$(echo "$create_out" | jq -r '.number')
        log OK "Created GitHub project: $project_title (#$GH_PROJECT_NUM)"
    else
        log INFO "Found existing project: $project_title (#$GH_PROJECT_NUM)"
    fi

    gh_try "link project" gh project link "$GH_PROJECT_NUM" --owner "$GH_OWNER" --repo "$GH_OWNER_REPO" || true

    GH_PROJECT_NODE_ID=$(gh_try "get project ID" gh project view "$GH_PROJECT_NUM" --owner "$GH_OWNER" --format json --jq '.id') || {
        GH_ENABLED=false
        return 1
    }

    # Create labels (idempotent)
    gh label create "autopilot:epic" --repo "$GH_OWNER_REPO" --color "0052CC" --description "Autopilot epic" 2>/dev/null || true
    gh label create "autopilot:task" --repo "$GH_OWNER_REPO" --color "5319E7" --description "Autopilot task" 2>/dev/null || true

    # ── Status field setup ──────────────────────────────────────────────────
    local fields_json
    fields_json=$(gh_try "list fields" gh project field-list "$GH_PROJECT_NUM" --owner "$GH_OWNER" --format json) || {
        GH_ENABLED=false; return 1
    }

    local existing_status_id
    existing_status_id=$(echo "$fields_json" | jq -r '.fields[] | select(.name == "Status") | .id' 2>/dev/null | head -1)

    if [[ -n "$existing_status_id" ]] && [[ "$existing_status_id" != "null" ]]; then
        # Status field exists — check for required options
        local has_todo has_inprog has_done
        has_todo=$(echo "$fields_json" | jq -r '[.fields[] | select(.name == "Status") | .options[].name] | index("Todo") // empty' 2>/dev/null)
        has_inprog=$(echo "$fields_json" | jq -r '[.fields[] | select(.name == "Status") | .options[].name] | index("In Progress") // empty' 2>/dev/null)
        has_done=$(echo "$fields_json" | jq -r '[.fields[] | select(.name == "Status") | .options[].name] | index("Done") // empty' 2>/dev/null)

        if [[ -n "$has_todo" ]] && [[ -n "$has_inprog" ]] && [[ -n "$has_done" ]]; then
            log INFO "Status field has required options (Todo, In Progress, Done)"
        else
            # Options don't match — create a new autopilot-specific project
            log WARN "Project #$GH_PROJECT_NUM Status field missing required options — creating new autopilot project"

            local create_out
            create_out=$(gh_try "create new project" gh project create --owner "$GH_OWNER" --title "$project_title" --format json) || {
                GH_ENABLED=false; return 1
            }
            GH_PROJECT_NUM=$(echo "$create_out" | jq -r '.number')
            log OK "Created new autopilot project: $project_title (#$GH_PROJECT_NUM)"

            gh_try "link new project" gh project link "$GH_PROJECT_NUM" --owner "$GH_OWNER" --repo "$GH_OWNER_REPO" || true

            GH_PROJECT_NODE_ID=$(gh_try "get new project ID" gh project view "$GH_PROJECT_NUM" --owner "$GH_OWNER" --format json --jq '.id') || {
                GH_ENABLED=false; return 1
            }

            # Re-read fields from new project
            fields_json=$(gh_try "list new fields" gh project field-list "$GH_PROJECT_NUM" --owner "$GH_OWNER" --format json) || {
                GH_ENABLED=false; return 1
            }
            existing_status_id=$(echo "$fields_json" | jq -r '.fields[] | select(.name == "Status") | .id' 2>/dev/null | head -1)
        fi
    fi

    # If still no Status field (fresh project), create one
    if [[ -z "$existing_status_id" ]] || [[ "$existing_status_id" == "null" ]]; then
        gh_try "create Status field" gh project field-create "$GH_PROJECT_NUM" --owner "$GH_OWNER" \
            --name "Status" --data-type "SINGLE_SELECT" \
            --single-select-options "Todo,In Progress,Done" || {
            GH_ENABLED=false; return 1
        }

        fields_json=$(gh_try "read fields" gh project field-list "$GH_PROJECT_NUM" --owner "$GH_OWNER" --format json) || {
            GH_ENABLED=false; return 1
        }
    fi

    GH_FIELD_STATUS_ID=$(echo "$fields_json" | jq -r '.fields[] | select(.name == "Status") | .id')

    # Cache only the 3 required status options
    local options
    options=$(echo "$fields_json" | jq -c '.fields[] | select(.name == "Status") | .options[]' 2>/dev/null)
    while IFS= read -r opt; do
        [[ -z "$opt" ]] && continue
        local name id
        name=$(echo "$opt" | jq -r '.name')
        id=$(echo "$opt" | jq -r '.id')
        case "$name" in
            Todo|"In Progress"|Done) GH_STATUS_OPT["$name"]="$id" ;;
        esac
    done <<< "$options"

    _gh_write_cache "$env_file"
    log OK "GitHub project configured (#$GH_PROJECT_NUM) — IDs cached"
}

# Source the sync operations module
source "$SCRIPT_DIR/autopilot-github-sync.sh"
